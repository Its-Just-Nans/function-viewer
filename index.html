<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js webgl - geometry - cube</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

</head>

<body>
    <div id="help">
        <input type="text" id="formula" value="Math.sin(x)" />
        <div id="details" style="display: none;">
            <p style="display: block;margin:0px">You can use JavaScript Math object !</p>
            <p>Speed</p><input type="range" id="deplacement" min="0" max="2" value="0.5" step="0.01" />
            <br />
            <p>Distance between cube</p><input type="range" id="rapport" min="0" max="2" value="1" step="0.1" />
            <br />
            <button id="pause">Pause</button>
            <br />
            <p>Check code <a>here</a></p>
            <hr style="display: block;" />

        </div>
        <div id="more">More</div>
    </div>
    <style>
        body {
            margin: 0px;
        }

        hr {
            display: block;
            margin-block-start: 0.2em;
            margin-block-end: 0.2em;
        }

        #help {
            padding-top: 5px;
            padding-bottom: 5px;
            position: absolute;
            bottom: 0px;
            width: 100vw;
            text-align: center;
            background-color: whitesmoke;
            border-top: 1px solid black;
        }

        #details>* {
            display: inline;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
        }

        #more {
            display: inline;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
            font-weight: bold;
        }

        #more:hover {
            cursor: pointer;
        }
    </style>

    <script type="module">
        const sanitizeFormula = (value) => {
            value = value.replace(/([^A-Za-z]?)x([^A-Za-z]?)/g, "$1oneMesh.position.x$2");
            value = value.replace(/([^A-Za-z]?)y([^A-Za-z]?)/g, "$1oneMesh.position.y$2");
            value = value.replace(/([^A-Za-z]?)z([^A-Za-z]?)/g, "$1oneMesh.position.z$2");
            return value;
        }


        import * as THREE from 'https://cdn.skypack.dev/three';
        import { OrbitControls } from 'https://cdn.skypack.dev/three/examples/jsm/controls/OrbitControls.js';
        let camera, scene, renderer;
        let axesHelper, controls;
        let x_deplacement = -100;
        let meshes = [];
        let boolean = true;
        let myMESH, myMESH2;
        let dateEnd;
        let formula = sanitizeFormula(document.getElementById("formula").value);
        let deplacement = parseFloat(document.getElementById("deplacement").value);
        let rapport = parseFloat(document.getElementById("rapport").value);
        let reset = false;
        init();
        animate();
        document.getElementById("more").addEventListener("click", (event) => {
            const element = document.getElementById("details");
            if (element.style.display == "none") {
                event.target.innerHTML = "Less";
                element.style.display = "block";
            } else {
                event.target.innerHTML = "More";
                element.style.display = "none";
            }
        })
        function init() {
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 20000);
            camera.position.set(50, 50, 50);
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xF5F5F5);
            let z = 0;
            let y = 0;
            let x = 0;
            const line = 10;
            const largeur = 1;
            for (let count = 0, max = line * line; count < max; count++) {
                const geometry = new THREE.BoxGeometry(largeur, largeur, largeur);
                const material = new THREE.MeshBasicMaterial();
                material.color = new THREE.Color(`rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`);
                const mesh = new THREE.Mesh(geometry, material);
                scene.add(mesh);
                meshes.push(mesh);
            }
            meshes.forEach((oneMesh, index) => {
                oneMesh.position.x = oneMesh.position.x - rapport * index;
            });
            const mesh1 = new THREE.Mesh(new THREE.BoxGeometry(largeur, largeur, largeur), new THREE.MeshBasicMaterial({ color: "green" }));
            mesh1.position.y = 20;
            scene.add(mesh1);
            const mesh2 = new THREE.Mesh(new THREE.BoxGeometry(largeur, largeur, largeur), new THREE.MeshBasicMaterial({ color: "red" }));
            mesh2.position.x = 20;
            scene.add(mesh2);
            const mesh3 = new THREE.Mesh(new THREE.BoxGeometry(largeur, largeur, largeur), new THREE.MeshBasicMaterial({ color: "blue" }));
            mesh3.position.z = 20;
            scene.add(mesh3);

            axesHelper = new THREE.AxesHelper(10000);
            scene.add(axesHelper);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.update();
            document.body.appendChild(renderer.domElement);
            window.addEventListener('resize', onWindowResize);

        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }


        function animate() {
            requestAnimationFrame(animate);
            if (boolean == true) {
                const longeurMax = 100;
                meshes.forEach((oneMesh, index) => {
                    if (oneMesh.position.x > longeurMax) {
                        oneMesh.position.x = -longeurMax;
                    } else {
                        oneMesh.position.x = oneMesh.position.x + deplacement;
                    }
                    try {
                        oneMesh.position.y = eval(formula);
                    } catch (e) {
                        oneMesh.position.y = oneMesh.position.x;
                    }
                });
            }
            controls.update();
            renderer.render(scene, camera);

        }

        document.getElementsByTagName("canvas")[0].addEventListener("keypress", () => {
            boolean = !boolean;
        });
        document.getElementById("formula").addEventListener("input", (event) => {
            formula = sanitizeFormula(event.target.value);
        });
        document.getElementById("pause").addEventListener("click", (event) => {
            if (event.target.innerHTML == "Pause") {
                event.target.innerHTML = "Play";
            } else {
                event.target.innerHTML = "Pause";
            }
            boolean = !boolean;
        });
        document.getElementById("deplacement").addEventListener("input", (event) => {
            deplacement = parseFloat(event.target.value);
        })
        document.getElementById("rapport").addEventListener("input", (event) => {
            rapport = parseFloat(event.target.value);
            meshes.forEach((oneMesh, index) => {
                oneMesh.position.x = 0 - rapport * index;
            });
        })

    </script>

</body>

</html>